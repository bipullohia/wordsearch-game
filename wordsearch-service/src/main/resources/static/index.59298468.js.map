{"mappings":"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","sources":["src/js/grid.js","src/js/index.js"],"sourcesContent":["export class Grid {\n\n    constructor() {\n        this.wordSelectedMode = false;\n        this.selectedItems = [];\n        this.firstSelectedItem;\n        this.gridSection;\n        this.words = [];\n        this.foundWords = [];\n    }\n\n    getCellsInRange(firstLetter, currentLetter) {\n        let cellsInRange = [];\n        //swapping the letters if it is inverse horizontal/vertical/diagonal\n        if(firstLetter.x > currentLetter.x || firstLetter.y > currentLetter.y) {\n            [firstLetter, currentLetter] = [currentLetter, firstLetter];\n        }\n\n        //horizontal selection\n        if(firstLetter.x === currentLetter.x) {\n            for(let i = firstLetter.y; i <= currentLetter.y; i++){\n                cellsInRange.push(this.gridSection.querySelector(`td[data-x=\"${currentLetter.x}\"][data-y=\"${i}\"]`));\n            }\n        } else if(firstLetter.y === currentLetter.y) { //vertical selection\n            for(let i = firstLetter.x; i <= currentLetter.x; i++){\n                cellsInRange.push(this.gridSection.querySelector(`td[data-x=\"${i}\"][data-y=\"${currentLetter.y}\"]`));\n            }\n        } else if(firstLetter.y - currentLetter.y === firstLetter.x - currentLetter.x) { //diagonal selection\n            let diff = currentLetter.y - firstLetter.y;\n            for(let i = 0; i <= diff; i++){\n                cellsInRange.push(this.gridSection.querySelector(`td[data-x=\"${firstLetter.x + i}\"][data-y=\"${firstLetter.y + i}\"]`));\n            }\n        }\n\n        return cellsInRange;\n    }\n\n    renderGrid(gridSize, gridContent) {\n        var gridSection = document.getElementsByClassName(\"grid-section\")[0];\n        //to remove the old table grid when before we generate a new table for word grid\n        if(gridSection.lastChild){\n            gridSection.removeChild(gridSection.lastChild);\n        }\n        this.gridSection = gridSection;\n        const tbl = document.createElement(\"table\");\n        const tblBody = document.createElement(\"tbody\");\n        let index = 0;\n\n        for (let i = 0; i < gridSize; i++) {\n            const row = document.createElement(\"tr\");\n            for (let j = 0; j < gridSize; j++) {\n                let letter = gridContent[index++];\n                const cell = document.createElement(\"td\");\n                const cellText = document.createTextNode(letter);\n                cell.appendChild(cellText);\n                cell.setAttribute('data-x', i);\n                cell.setAttribute('data-y', j);\n                cell.setAttribute('data-letter', letter);\n                row.appendChild(cell);\n            }\n            tblBody.appendChild(row);\n        }\n        tbl.appendChild(tblBody);\n        document.body.appendChild(tbl);\n        gridSection.appendChild(tbl);\n\n\n        //event handlers for mouseup/mousedown/mousemove\n        tbl.addEventListener(\"mousedown\", (e) => {\n            this.wordSelectedMode = true;\n            let cell = e.target;\n            let x = +cell.getAttribute('data-x');\n            let y = +cell.getAttribute('data-y');\n            this.firstSelectedItem = ({\n                x, y\n            });  \n        });\n\n        tbl.addEventListener(\"mousemove\", (e) => {\n            if(this.wordSelectedMode){\n                let cell = e.target;\n                let x = +cell.getAttribute('data-x');\n                let y = +cell.getAttribute('data-y');\n                this.selectedItems.forEach(cell => cell.classList.remove(\"selected\"));\n                this.selectedItems = this.getCellsInRange(this.firstSelectedItem, {x,y});\n                this.selectedItems.forEach(cell => cell.classList.add(\"selected\"));\n            }\n        });\n\n        tbl.addEventListener(\"mouseup\", () => {\n            this.wordSelectedMode = false;\n            const selectedWord = this.selectedItems.reduce((word, cell) => word += cell.getAttribute(\"data-letter\"), '');\n            const inverseSelectedWord = selectedWord.split(\"\").reverse().join(\"\");\n            if(this.words.indexOf(selectedWord) !== -1){\n                this.foundWords.push(selectedWord);\n            }else if(this.words.indexOf(inverseSelectedWord) !== -1){\n                this.foundWords.push(inverseSelectedWord);\n            }else {\n                this.selectedItems.forEach(cell => {\n                    cell.classList.remove(\"selected\"); //the e will contain the entire object with x, y, letter and cell\n                });\n            }\n            this.selectedItems = [];\n        });\n    }\n\n}","import { Grid } from \"./grid\";\n\nconst submitWordButton = document.querySelector(\".submit-words\");\n// const GRID_SIZE = 10;\n\n\nsubmitWordButton.onclick = function(){\n    fetchWordGridFromService();\n}\n\nasync function fetchWordGridFromService(){\n    const grid = new Grid();\n    const wordListByUser = document.getElementById(\"grid-words\").value;\n    const gridSizeByUser = document.getElementById(\"grid-size\").value;\n    \n    grid.words = wordListByUser.split(\",\");\n    // const host = 'http://localhost:8090/wordgrid';\n    const host = './wordgrid'; //this is relative host address - used when we bundle the static files with the springboot service\n    const uri = `${host}?gridSize=${gridSizeByUser}&wordList=${wordListByUser}`;\n    \n    let response = await fetch(uri);\n    let wordGridContent = await response.text();\n    let wordGridArray = wordGridContent.split(\" \");\n    \n    //filtering the elements which are empty\n    wordGridArray = wordGridArray.filter((e) => {\n        return e != \"\";\n    });\n    \n    grid.renderGrid(gridSizeByUser, wordGridArray);\n    const userInputWordlistSectionNode = document.createTextNode(grid.words);\n    let wordInputDisplaySection = document.querySelector(\".user-input-wordlist\");\n    if(wordInputDisplaySection.lastChild){\n        wordInputDisplaySection.removeChild(wordInputDisplaySection.lastChild);\n    }\n    wordInputDisplaySection.appendChild(userInputWordlistSectionNode);\n    \n}"],"names":["$29289ae2f853543e$export$ef2184bd89960b14","constructor","this","wordSelectedMode","selectedItems","firstSelectedItem","gridSection","words","foundWords","getCellsInRange","firstLetter","currentLetter","cellsInRange","x","y","i","push","querySelector","diff","renderGrid","gridSize","gridContent","document","getElementsByClassName","lastChild","removeChild","tbl","createElement","tblBody","index","row","j","letter","cell","cellText","createTextNode","appendChild","setAttribute","body","addEventListener","e","target","getAttribute","forEach","classList","remove","add","selectedWord","reduce","word","inverseSelectedWord","split","reverse","join","indexOf","onclick","async","grid","wordListByUser","getElementById","value","gridSizeByUser","uri","response","fetch","wordGridArray","text","filter","userInputWordlistSectionNode","wordInputDisplaySection","$8f6a480bb40b134f$var$fetchWordGridFromService"],"version":3,"file":"index.59298468.js.map"}